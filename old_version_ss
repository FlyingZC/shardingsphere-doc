commit fb186baacf4052ccc1ed2131d81719add27fae92
Author: Liang Zhang <zhangliang@apache.org>
Date:   Tue Jan 24 00:29:55 2023 +0800

    Add default type logic in TypedSPIRegistry (#23711)
    
    * Refactor ReadwriteSplittingRuleStatementChecker
    
    * Add default type logic in TypedSPIRegistry
    
    * Add default type logic in TypedSPIRegistry

diff --git a/docs/blog/content/material/2022_03_23_Apache_ShardingSphere_Proxy_Performance_with_PostgreSQL_is_Improved_26.8%_with_Version_5.1.0.en.md b/docs/blog/content/material/2022_03_23_Apache_ShardingSphere_Proxy_Performance_with_PostgreSQL_is_Improved_26.8%_with_Version_5.1.0.en.md
index 9fc0c713bdc..9fc6287288a 100644
--- a/docs/blog/content/material/2022_03_23_Apache_ShardingSphere_Proxy_Performance_with_PostgreSQL_is_Improved_26.8%_with_Version_5.1.0.en.md
+++ b/docs/blog/content/material/2022_03_23_Apache_ShardingSphere_Proxy_Performance_with_PostgreSQL_is_Improved_26.8%_with_Version_5.1.0.en.md
@@ -60,7 +60,7 @@ Taking a frequently called ShardingSphere class `org.apache.shardingsphere.infra
         this.executorDriverManager = executorDriverManager;
         this.option = option;
         sqlExecutionUnitBuilder = TYPE_TO_BUILDER_MAP.computeIfAbsent(type, 
-                key -> TypedSPIRegistry.getRegisteredService(SQLExecutionUnitBuilder.class, key, new Properties()));
+                key -> TypedSPIRegistry.getService(SQLExecutionUnitBuilder.class, key, new Properties()));
     }
 ```
 
@@ -69,7 +69,7 @@ In the code above, only two `type` will be passed into `computeIfAbsent`, and mo
 ```java
 SQLExecutionUnitBuilder result;
 if (null == (result = TYPE_TO_BUILDER_MAP.get(type))) {
-    result = TYPE_TO_BUILDER_MAP.computeIfAbsent(type, key -> TypedSPIRegistry.getRegisteredService(SQLExecutionUnitBuilder.class, key, new Properties()));
+    result = TYPE_TO_BUILDER_MAP.computeIfAbsent(type, key -> TypedSPIRegistry.getService(SQLExecutionUnitBuilder.class, key, new Properties()));
 }
 return result;
 ```
diff --git "a/docs/blog/content/material/2022_06_16_Understanding_Apache_ShardingSphere's_SPI_and_why_it\342\200\231s_simpler_than_Dubbo\342\200\231s.en.md" "b/docs/blog/content/material/2022_06_16_Understanding_Apache_ShardingSphere's_SPI_and_why_it\342\200\231s_simpler_than_Dubbo\342\200\231s.en.md"
index 7eebdcf246f..5b6654b5d9c 100644
--- "a/docs/blog/content/material/2022_06_16_Understanding_Apache_ShardingSphere's_SPI_and_why_it\342\200\231s_simpler_than_Dubbo\342\200\231s.en.md"
+++ "b/docs/blog/content/material/2022_06_16_Understanding_Apache_ShardingSphere's_SPI_and_why_it\342\200\231s_simpler_than_Dubbo\342\200\231s.en.md"
@@ -110,16 +110,16 @@ public final class DialectTableMetaDataLoaderFactory {
      * @return new instance of dialect table meta data loader
      */
     public static Optional<DialectTableMetaDataLoader> newInstance(final DatabaseType databaseType) {
-        return TypedSPIRegistry.findRegisteredService(DialectTableMetaDataLoader.class, databaseType.getName());
+        return TypedSPIRegistry.findService(DialectTableMetaDataLoader.class, databaseType.getName());
     }
 }
 ```
-Here you can see that a static block is used, and all the `DialectTableMetaDataLoader` implementation classes are registered through `ShardingSphereServiceLoader.register` while class loading is in process. By using `TypedSPIRegistry.findRegisteredService`, we can get our specified spi extension class.
+Here you can see that a static block is used, and all the `DialectTableMetaDataLoader` implementation classes are registered through `ShardingSphereServiceLoader.register` while class loading is in process. By using `TypedSPIRegistry.findService`, we can get our specified spi extension class.
 
 ```
-TypedSPIRegistry.findRegisteredService(final Class<T> spiClass, final String type)
+TypedSPIRegistry.findService(final Class<T> spiClass, final String type)
 ```
-So we just have to pay attention to `ShardingSphereServiceLoader.register` and `ypedSPIRegistry.findRegisteredService` approaches.
+So we just have to pay attention to `ShardingSphereServiceLoader.register` and `TypedSPIRegistry.findService` approaches.
 
 **`ShardingSphereServiceLoader`**
 
@@ -215,10 +215,10 @@ private static <T> Collection<Object> load(final Class<T> serviceInterface) {
 ```
 **`TypedSPIRegistry`**
 
-The `findRegisteredService` method in `TypedSPIRegistry` is essentially a call to the `getSingletonServiceInstancesmethod` of the `ShardingSphereServiceLoader`.
+The `findService` method in `TypedSPIRegistry` is essentially a call to the `getSingletonServiceInstancesmethod` of the `ShardingSphereServiceLoader`.
 
 ```java
-public static <T extends StatelessTypedSPI> Optional<T> findRegisteredService(final Class<T> spiClass, final String type) {
+public static <T extends StatelessTypedSPI> Optional<T> findService(final Class<T> spiClass, final String type) {
         for (T each : ShardingSphereServiceLoader.getSingletonServiceInstances(spiClass)) {
             if (matchesType(type, each)) {
                 return Optional.of(each);
